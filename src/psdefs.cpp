/*************************************************************************
** psdefs.cpp                                                           **
**                                                                      **
** This file is part of dvisvgm -- a fast DVI to SVG converter          **
** Copyright (C) 2005-2023 Martin Gieseking <martin.gieseking@uos.de>   **
**                                                                      **
** This program is free software; you can redistribute it and/or        **
** modify it under the terms of the GNU General Public License as       **
** published by the Free Software Foundation; either version 3 of       **
** the License, or (at your option) any later version.                  **
**                                                                      **
** This program is distributed in the hope that it will be useful, but  **
** WITHOUT ANY WARRANTY; without even the implied warranty of           **
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         **
** GNU General Public License for more details.                         **
**                                                                      **
** You should have received a copy of the GNU General Public License    **
** along with this program; if not, see <http://www.gnu.org/licenses/>. **
*************************************************************************/

#include "PSInterpreter.hpp"

const char *PSInterpreter::PSDEFS =
"<</Install{matrix setmatrix}/HWResolution[72 72]/PageSize[10000 10000]/Imaging"
"BBox null>>setpagedevice/@dodraw true store/@GD globaldict def/@SD systemdict "
"def/@UD userdict def @GD/@nulldev false put @GD/@patcnt 0 put true setglobal @"
"SD/:save @SD/save get put @SD/:restore @SD/restore get put @SD/:gsave @SD/gsav"
"e get put @SD/:grestore @SD/grestore get put @SD/:grestoreall @SD/grestoreall "
"get put @SD/:newpath @SD/newpath get put @SD/:stroke @SD/stroke get put @SD/:f"
"ill @SD/fill get put @SD/:eofill @SD/eofill get put @SD/:clip @SD/clip get put"
" @SD/:eoclip @SD/eoclip get put @SD/:charpath @SD/charpath get put @SD/:show @"
"SD/show get put @SD/:stringwidth @SD/stringwidth get put @SD/:nulldevice @SD/n"
"ulldevice get put @SD/:image @SD/image get put @SD/:colorimage @SD/colorimage "
"get put @SD/.setopacityalpha known not{@SD/.setopacityalpha{pop}put}if @SD/.se"
"tshapealpha known not{@SD/.setshapealpha{pop}put}if @SD/.setblendmode known no"
"t{@SD/.setblendmode{pop}put}if @SD/prseq{-1 1{-1 roll =only( )print}for(\\n)pr"
"int}put @SD/prcmd{( )exch(\\ndvi.)3{print}repeat prseq}put @SD/cvxall{{cvx}for"
"all}put @SD/defpr{[exch/copy cvx @SD 4 index[/get/exec]cvxall 5 index 3 index "
"dup length string cvs 1 index 0 eq{8 -2 roll pop pop}if/prcmd cvx]cvx bind def"
"}put @SD/querypos{{currentpoint}stopped{$error/newerror false put}{2(querypos)"
"prcmd}ifelse}put @SD/applyscalevals{1 0 dtransform exch dup mul exch dup mul a"
"dd sqrt 0 1 dtransform exch dup mul exch dup mul add sqrt 1 0 dtransform dup m"
"ul exch dup dup mul 3 -1 roll add dup 0 eq{pop}{sqrt div}ifelse 3(applyscaleva"
"ls)prcmd}put @SD/prpath{{2(moveto)prcmd}{2(lineto)prcmd}{6(curveto)prcmd}{0(cl"
"osepath)prcmd}pathforall}put @SD/nulldevice{@GD/@nulldev true put :nulldevice "
"1 1(setnulldevice)prcmd}put @SD/charpath{/@dodraw false store :charpath/@dodra"
"w true store}put @SD/stringwidth{/@dodraw false store :stringwidth/@dodraw tru"
"e store}put @SD/show{@dodraw @GD/@nulldev get not and{dup :gsave currentpoint "
"2{50 mul exch}repeat :newpath moveto 50 50/scale sysexec true charpath fill :g"
"restore/@dodraw false store :show/@dodraw true store}{:show}ifelse}put @SD/var"
"xyshow{dup 0 ge{<</chr 3 -1 roll string/prc 5 -1 roll/arr 7 -1 roll/str 9 -1 r"
"oll/idx 0>>begin 0 chr length str length 1 sub{str exch chr length getinterval"
"/chr exch store :gsave chr show :grestore currentpoint prc moveto/idx idx 1 ad"
"d store}for end}{pop pop show}ifelse}put @SD/xyshow{dup dup type/arraytype eq "
"exch length 0 gt and{dup length 2 idiv 2 index length exch idiv}{-1}ifelse{exc"
"h arr idx 2 mul get add exch arr idx 2 mul 1 add get add}exch varxyshow}put @S"
"D/xshow{dup dup type/arraytype eq exch length 0 gt and{dup length 2 index leng"
"th exch idiv}{-1}ifelse{exch arr idx get add exch}exch varxyshow}put @SD/yshow"
"{dup dup type/arraytype eq exch length 0 gt and{dup length 2 index length exch"
" idiv}{-1}ifelse{arr idx get add}exch varxyshow}put @SD/awidthshow{{1 string d"
"up 0 5 index put :gsave show :grestore pop 0 rmoveto 3 index eq{4 index 4 inde"
"x rmoveto}if 1 index 1 index rmoveto}exch cshow 5{pop}repeat}put @SD/widthshow"
"{0 0 3 -1 roll awidthshow}put @SD/ashow{0 0 0 6 3 roll awidthshow}put @SD/newp"
"ath{:newpath 1 1(newpath)prcmd}put @SD/stroke{@dodraw @GD/@nulldev get not and"
"{prcolor 0 1(newpath)prcmd prpath 0(stroke)prcmd :newpath}{:stroke}ifelse}put "
"@SD/fill{@dodraw @GD/@nulldev get not and{prcolor 0 1(newpath)prcmd prpath 0(f"
"ill)prcmd :newpath}{:fill}ifelse}put @SD/eofill{@dodraw @GD/@nulldev get not a"
"nd{prcolor 0 1(newpath)prcmd prpath 0(eofill)prcmd :newpath}{:eofill}ifelse}pu"
"t/.fillstroke{:gsave fill :grestore .swapcolors stroke .swapcolors}bind def/.e"
"ofillstroke{:gsave eofill :grestore .swapcolors stroke .swapcolors}bind def @S"
"D/clip{:clip @GD/@nulldev get not{0 1(newpath)prcmd prpath 0(clip)prcmd}if}put"
" @SD/eoclip{:eoclip @GD/@nulldev get not{0 1(newpath)prcmd prpath 0(eoclip)prc"
"md}if}put @SD/shfill{begin currentdict/ShadingType known currentdict/ColorSpac"
"e known and currentdict/DataSource known and currentdict/Function known not an"
"d ShadingType 4 ge{DataSource type/arraytype eq{<</DeviceGray 1/DeviceRGB 3/De"
"viceCMYK 4/bgknown currentdict/Background known/bbknown currentdict/BBox known"
">>begin currentdict ColorSpace known{ShadingType ColorSpace load bgknown{1 Bac"
"kground aload pop}{0}ifelse bbknown{1 BBox aload pop}{0}ifelse ShadingType 5 e"
"q{VerticesPerRow}if DataSource aload length 4 add bgknown{ColorSpace load add}"
"if bbknown{4 add}if ShadingType 5 eq{1 add}if(shfill)prcmd}if end}if}if end}pu"
"t @SD/image{dup type/dicttype eq{dup}{<</Width 6 index/Height 7 index/colorimg"
" false>>}ifelse @execimg}put @SD/colorimage{<<2 index{/Width 2 index 8 add ind"
"ex/Height 4 index 9 add index}{/Width 8 index/Height 9 index}ifelse/colorimg t"
"rue>>@execimg}put/@imgbase(./)def/@imgdevice(jpeg)def/@execimg{@GD/@imgcnt 2 c"
"opy .knownget{1 add}{1}ifelse put begin<</imgdev null/imgid @GD/@imgcnt get/is"
"png @imgdevice 0 3 getinterval(png)eq dup/suffix exch{(.png)}{(.jpg)}ifelse/co"
"lorimg currentdict/colorimg .knownget dup{pop}if/colordev 1 index currentcolor"
"space dup length 1 ne exch 0 get/DeviceGray ne or or>>begin @imgdevice(png)ne "
"@imgdevice(jpeg)ne and{@imgdevice cvn}{colordev{ispng{/png16m}{/jpeg}ifelse}{i"
"spng{/pnggray}{/jpeggray}ifelse}ifelse}ifelse dup devicedict exch known{:gsave"
"/imgdev exch finddevice def mark/OutputFile @imgbase imgid 20 string cvs strco"
"ncat suffix strconcat/PageSize[Width Height]/UseFastColor true ispng{@imgdevic"
"e(pngmonod)eq{/MinFeatureSize where{pop/MinFeatureSize MinFeatureSize}if}if}{/"
"JPEGQ where{pop/JPEGQ JPEGQ}if}ifelse imgdev putdeviceprops setdevice[Width 0 "
"0 Height neg 0 Height]/setmatrix sysexec colorimg{:colorimage}{:image}ifelse/c"
"opypage sysexec mark/OutputFile()imgdev putdeviceprops pop :grestore imgid Wid"
"th Height 3(image)prcmd}{pop colorimg{:colorimage}{:image}ifelse}ifelse end en"
"d}def/@rect{4 -2 roll moveto exch dup 0 rlineto exch 0 exch rlineto neg 0 rlin"
"eto closepath}bind def/@rectcc{4 -2 roll moveto 2 copy 0 lt exch 0 lt xor{dup "
"0 exch rlineto exch 0 rlineto neg 0 exch rlineto}{exch dup 0 rlineto exch 0 ex"
"ch rlineto neg 0 rlineto}ifelse closepath}bind def @SD/rectclip{:newpath dup t"
"ype/arraytype eq{aload length 4 idiv{@rectcc}repeat}{@rectcc}ifelse clip :newp"
"ath}put @SD/rectfill{:gsave :newpath dup type/arraytype eq{aload length 4 idiv"
"{@rectcc}repeat}{@rectcc}ifelse fill :grestore}put @SD/rectstroke{gsave :newpa"
"th dup type/arraytype eq{aload length 4 idiv{@rect}repeat}{@rect}ifelse stroke"
" grestore}put false setglobal @SD readonly pop/initclip 0 defpr/clippath 0 def"
"pr/sysexec{@SD exch get exec}def/adddot{dup length 1 add string dup 0 46 put d"
"up 3 -1 roll 1 exch putinterval}def/setlinewidth{dup/setlinewidth sysexec 1(se"
"tlinewidth)prcmd}def/setlinecap 1 defpr/setlinejoin 1 defpr/setmiterlimit 1 de"
"fpr/setdash{mark 3 1 roll 2 copy/setdash sysexec exch aload length 1 add -1 ro"
"ll counttomark(setdash)prcmd pop}def/@setpagedevice{pop<<>>/setpagedevice syse"
"xec matrix setmatrix newpath 0(setpagedevice)prcmd}def/@checknulldev{@GD/@null"
"dev get{currentpagedevice maxlength 0 ne{@GD/@nulldev false put 0 1(setnulldev"
"ice)prcmd}if}if}def/prcolor{currentcolorspace @setcolorspace currentrgbcolor 3"
"(setrgbcolor)prcmd}def/printgstate{@dodraw @GD/@nulldev get not and{matrix cur"
"rentmatrix aload pop 6(setmatrix)prcmd applyscalevals currentlinewidth 1(setli"
"newidth)prcmd currentlinecap 1(setlinecap)prcmd currentlinejoin 1(setlinejoin)"
"prcmd currentmiterlimit 1(setmiterlimit)prcmd revision dup 952 lt{pop}{.curren"
"tblendmode .setblendmode 952 eq{.currentopacityalpha .setopacityalpha .current"
"shapealpha .setshapealpha}{.currentalphaisshape{1}{0}ifelse 1(setalphaisshape)"
"prcmd .currentstrokeconstantalpha 1(setstrokeconstantalpha)prcmd .currentfillc"
"onstantalpha 1(setfillconstantalpha)prcmd}ifelse}ifelse prcolor currentdash ma"
"rk 3 1 roll exch aload length 1 add -1 roll counttomark(setdash)prcmd pop}if}d"
"ef/strconcat{exch dup length 2 index length add string dup dup 4 2 roll copy l"
"ength 4 -1 roll putinterval}def/setgstate{/setgstate sysexec printgstate}def/s"
"ave{@UD begin/@saveID vmstatus pop pop def end :save @saveID 1(save)prcmd}def/"
"restore{:restore @checknulldev printgstate @UD/@saveID known{@UD begin @saveID"
" end}{0}ifelse 1(restore)prcmd}def/gsave 0 defpr/grestore{:grestore @checknull"
"dev printgstate 0(grestore)prcmd}def/grestoreall{:grestoreall @checknulldev se"
"tstate 0(grestoreall)prcmd}def/rotate{dup type/arraytype ne @dodraw and{dup 1("
"rotate)prcmd}if/rotate sysexec applyscalevals}def/scale{dup type/arraytype ne "
"@dodraw and{2 copy 2(scale)prcmd}if/scale sysexec applyscalevals}def/translate"
"{dup type/arraytype ne @dodraw and{2 copy 2(translate)prcmd}if/translate sysex"
"ec}def/setmatrix{dup/setmatrix sysexec @dodraw{aload pop 6(setmatrix)prcmd app"
"lyscalevals}{pop}ifelse}def/initmatrix{matrix setmatrix}def/concat{matrix curr"
"entmatrix matrix concatmatrix setmatrix}def/makepattern{gsave<</mx 3 -1 roll>>"
"begin<</XUID[1000000 @patcnt]>>copy mx/makepattern sysexec dup begin PatternTy"
"pe 2 lt{PatternType @patcnt BBox aload pop XStep YStep PaintType mx aload pop "
"15(makepattern)prcmd :newpath matrix setmatrix dup PaintProc 0 1(makepattern)p"
"rcmd @GD/@patcnt @patcnt 1 add put}if end end grestore}def/setpattern{dup begi"
"n PatternType end 1 eq{begin PaintType 1 eq{XUID aload pop exch pop 1}{:gsave["
"currentcolorspace aload length -1 roll pop]/setcolorspace sysexec/setcolor sys"
"exec XUID aload pop exch pop currentrgbcolor :grestore 4}ifelse(setpattern)prc"
"md currentcolorspace 0 get/Pattern ne{[/Pattern currentcolorspace]/setcolorspa"
"ce sysexec}if currentcolorspace @setcolorspace end}{/setpattern sysexec}ifelse"
"}def/setcolor{dup type/dicttype eq{setpattern}{/setcolor sysexec/currentrgbcol"
"or sysexec setrgbcolor}ifelse}def/setcolorspace{dup/setcolorspace sysexec @set"
"colorspace}def/@setcolorspace{dup type/arraytype eq{0 get}if/Pattern eq{1}{0}i"
"felse 1(setcolorspace)prcmd}def/setgray 1 defpr/setcmykcolor 4 defpr/sethsbcol"
"or 3 defpr/setrgbcolor 3 defpr/.setalphaisshape{@SD/.setalphaisshape known{dup"
"/.setalphaisshape sysexec}if{1}{0}ifelse 1(setalphaisshape)prcmd}bind def/.set"
"fillconstantalpha{@SD/.setfillconstantalpha known{dup/.setfillconstantalpha sy"
"sexec}if 1(setfillconstantalpha)prcmd}bind def/.setstrokeconstantalpha{@SD/.se"
"tstrokeconstantalpha known{dup/.setstrokeconstantalpha sysexec}if 1(setstrokec"
"onstantalpha)prcmd}bind def/.setopacityalpha{false .setalphaisshape dup .setfi"
"llconstantalpha .setstrokeconstantalpha}bind def/.setshapealpha{true .setalpha"
"isshape dup .setfillconstantalpha .setstrokeconstantalpha}bind def/.setblendmo"
"de{dup/.setblendmode sysexec<</Normal 0/Compatible 0/Multiply 1/Screen 2/Overl"
"ay 3/SoftLight 4/HardLight 5/ColorDodge 6/ColorBurn 7/Darken 8/Lighten 9/Diffe"
"rence 10/Exclusion 11/Hue 12/Saturation 13/Color 14/Luminosity 15/CompatibleOv"
"erprint 16>>exch get 1(setblendmode)prcmd}def/@pdfpagecount{(r)file runpdfbegi"
"n pdfpagecount runpdfend}def/@pdfpagebox{(r)file runpdfbegin dup dup 1 lt exch"
" pdfpagecount gt or{pop}{pdfgetpage/MediaBox pget pop aload pop}ifelse runpdfe"
"nd}def DELAYBIND{.bindnow}if ";

