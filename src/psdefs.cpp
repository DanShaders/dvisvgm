/*************************************************************************
** psdefs.cpp                                                           **
**                                                                      **
** This file is part of dvisvgm -- a fast DVI to SVG converter          **
** Copyright (C) 2005-2020 Martin Gieseking <martin.gieseking@uos.de>   **
**                                                                      **
** This program is free software; you can redistribute it and/or        **
** modify it under the terms of the GNU General Public License as       **
** published by the Free Software Foundation; either version 3 of       **
** the License, or (at your option) any later version.                  **
**                                                                      **
** This program is distributed in the hope that it will be useful, but  **
** WITHOUT ANY WARRANTY; without even the implied warranty of           **
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         **
** GNU General Public License for more details.                         **
**                                                                      **
** You should have received a copy of the GNU General Public License    **
** along with this program; if not, see <http://www.gnu.org/licenses/>. **
*************************************************************************/

#include "PSInterpreter.hpp"

const char *PSInterpreter::PSDEFS =
"<</Install{matrix setmatrix}/HWResolution[72 72]/PageSize[10000 10000]/Imaging"
"BBox null>>setpagedevice/@dodraw true store/@GD globaldict def/@SD systemdict "
"def/@UD userdict def @GD/@nulldev false put @GD/@patcnt 0 put true setglobal @"
"SD/:save @SD/save get put @SD/:restore @SD/restore get put @SD/:gsave @SD/gsav"
"e get put @SD/:grestore @SD/grestore get put @SD/:grestoreall @SD/grestoreall "
"get put @SD/:newpath @SD/newpath get put @SD/:stroke @SD/stroke get put @SD/:f"
"ill @SD/fill get put @SD/:eofill @SD/eofill get put @SD/:clip @SD/clip get put"
" @SD/:eoclip @SD/eoclip get put @SD/:charpath @SD/charpath get put @SD/:show @"
"SD/show get put @SD/:stringwidth @SD/stringwidth get put @SD/:nulldevice @SD/n"
"ulldevice get put @SD/:image @SD/image get put @SD/:colorimage @SD/colorimage "
"get put @SD/.setopacityalpha known not{@SD/.setopacityalpha{pop}put}if @SD/.se"
"tshapealpha known not{@SD/.setshapealpha{pop}put}if @SD/.setblendmode known no"
"t{@SD/.setblendmode{pop}put}if @SD/prseq{-1 1{-1 roll =only( )print}for(\\n)pr"
"int}put @SD/prcmd{( )exch(\\ndvi.)3{print}repeat prseq}put @SD/cvxall{{cvx}for"
"all}put @SD/defpr{[exch[/copy @SD]cvxall 5 -1 roll dup 6 1 roll[/get/exec]cvxa"
"ll 6 -1 roll dup 7 1 roll 4 -1 roll dup 5 1 roll dup length string cvs/prcmd c"
"vx]cvx def}put @SD/querypos{{currentpoint}stopped{$error/newerror false put}{2"
"(querypos)prcmd}ifelse}put @SD/applyscalevals{1 0 dtransform exch dup mul exch"
" dup mul add sqrt 0 1 dtransform exch dup mul exch dup mul add sqrt 1 0 dtrans"
"form dup mul exch dup dup mul 3 -1 roll add dup 0 eq{pop}{sqrt div}ifelse 3(ap"
"plyscalevals)prcmd}put @SD/prpath{{2(moveto)prcmd}{2(lineto)prcmd}{6(curveto)p"
"rcmd}{0(closepath)prcmd}pathforall}put @SD/nulldevice{@GD/@nulldev true put :n"
"ulldevice 1 1(setnulldevice)prcmd}put @SD/charpath{/@dodraw false store :charp"
"ath/@dodraw true store}put @SD/stringwidth{/@dodraw false store :stringwidth/@"
"dodraw true store}put @SD/show{@dodraw @GD/@nulldev get not and{dup :gsave cur"
"rentpoint 2{50 mul exch}repeat :newpath moveto 50 50/scale sysexec true charpa"
"th fill :grestore/@dodraw false store :show/@dodraw true store}{:show}ifelse}p"
"ut @SD/varxyshow{exch dup type/arraytype eq{<</arr 3 -1 roll/prc 5 -1 roll/chr"
" 1 string/idx 0>>begin{chr 0 3 -1 roll put :gsave chr show :grestore currentpo"
"int prc moveto/idx idx 1 add store}forall end}{pop show}ifelse}put @SD/xyshow{"
"{exch arr idx 2 mul get add exch arr idx 2 mul 1 add get add}varxyshow}put @SD"
"/xshow{{exch arr idx get add exch}varxyshow}put @SD/yshow{{arr idx get add}var"
"xyshow}put @SD/awidthshow{{1 string dup 0 5 index put :gsave show :grestore po"
"p 0 rmoveto 3 index eq{4 index 4 index rmoveto}if 1 index 1 index rmoveto}exch"
" cshow 5{pop}repeat}put @SD/widthshow{0 0 3 -1 roll awidthshow}put @SD/ashow{0"
" 0 0 6 3 roll awidthshow}put @SD/newpath{:newpath 1 1(newpath)prcmd}put @SD/st"
"roke{@dodraw @GD/@nulldev get not and{prcolor 0 1(newpath)prcmd prpath 0(strok"
"e)prcmd :newpath}{:stroke}ifelse}put @SD/fill{@dodraw @GD/@nulldev get not and"
"{prcolor 0 1(newpath)prcmd prpath 0(fill)prcmd :newpath}{:fill}ifelse}put @SD/"
"eofill{@dodraw @GD/@nulldev get not and{prcolor 0 1(newpath)prcmd prpath 0(eof"
"ill)prcmd :newpath}{:eofill}ifelse}put @SD/clip{:clip @GD/@nulldev get not{0 1"
"(newpath)prcmd prpath 0(clip)prcmd}if}put @SD/eoclip{:eoclip @GD/@nulldev get "
"not{0 1(newpath)prcmd prpath 0(eoclip)prcmd}}put @SD/shfill{begin currentdict/"
"ShadingType known currentdict/ColorSpace known and currentdict/DataSource know"
"n and currentdict/Function known not and ShadingType 4 ge{DataSource type/arra"
"ytype eq{<</DeviceGray 1/DeviceRGB 3/DeviceCMYK 4/bgknown currentdict/Backgrou"
"nd known/bbknown currentdict/BBox known>>begin currentdict ColorSpace known{Sh"
"adingType ColorSpace load bgknown{1 Background aload pop}{0}ifelse bbknown{1 B"
"Box aload pop}{0}ifelse ShadingType 5 eq{VerticesPerRow}if DataSource aload le"
"ngth 4 add bgknown{ColorSpace load add}if bbknown{4 add}if ShadingType 5 eq{1 "
"add}if(shfill)prcmd}if end}if}if end}put @SD/image{dup type/dicttype eq{dup}{<"
"</Width 6 index/Height 7 index/colorimg false>>}ifelse @execimg}put @SD/colori"
"mage{<<2 index{/Width 2 index 8 add index/Height 4 index 9 add index}{/Width 8"
" index/Height 9 index}ifelse/colorimg true>>@execimg}put/@imgbase(./)def/@imgd"
"evice(jpeg)def/@execimg{@GD/@imgcnt 2 copy .knownget{1 add}{1}ifelse put begin"
"<</imgdev null/imgid @GD/@imgcnt get/ispng @imgdevice 0 3 getinterval(png)eq d"
"up/suffix exch{(.png)}{(.jpg)}ifelse/colorimg currentdict/colorimg .knownget d"
"up{pop}if/colordev 1 index currentcolorspace dup length 1 ne exch 0 get/Device"
"Gray ne or or>>begin @imgdevice(png)ne @imgdevice(jpeg)ne and{@imgdevice cvn}{"
"colordev{ispng{/png16m}{/jpeg}ifelse}{ispng{/pnggray}{/jpeggray}ifelse}ifelse}"
"ifelse dup devicedict exch known{:gsave/imgdev exch finddevice def mark/Output"
"File @imgbase imgid 20 string cvs strconcat suffix strconcat/PageSize[Width He"
"ight]/UseFastColor true ispng{@imgdevice(pngmonod)eq{/MinFeatureSize where{pop"
"/MinFeatureSize MinFeatureSize}if}if}{/JPEGQ where{pop/JPEGQ JPEGQ}if}ifelse i"
"mgdev putdeviceprops setdevice[Width 0 0 Height neg 0 Height]/setmatrix sysexe"
"c colorimg{:colorimage}{:image}ifelse/copypage sysexec mark/OutputFile()imgdev"
" putdeviceprops pop :grestore imgid Width Height 3(image)prcmd}{pop colorimg{:"
"colorimage}{:image}ifelse}ifelse end end}def/@rect{4 -2 roll moveto exch dup 0"
" rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def/@rectcc{4 -2 rol"
"l moveto 2 copy 0 lt exch 0 lt xor{dup 0 exch rlineto exch 0 rlineto neg 0 exc"
"h rlineto}{exch dup 0 rlineto exch 0 exch rlineto neg 0 rlineto}ifelse closepa"
"th}bind def @SD/rectclip{:newpath dup type/arraytype eq{aload length 4 idiv{@r"
"ectcc}repeat}{@rectcc}ifelse clip :newpath}put @SD/rectfill{:gsave :newpath du"
"p type/arraytype eq{aload length 4 idiv{@rectcc}repeat}{@rectcc}ifelse fill :g"
"restore}put @SD/rectstroke{gsave :newpath dup type/arraytype eq{aload length 4"
" idiv{@rect}repeat}{@rect}ifelse stroke grestore}put false setglobal @SD reado"
"nly pop/initclip 0 defpr/clippath 0 defpr/sysexec{@SD exch get exec}def/adddot"
"{dup length 1 add string dup 0 46 put dup 3 -1 roll 1 exch putinterval}def/set"
"linewidth{dup/setlinewidth sysexec 1(setlinewidth)prcmd}def/setlinecap 1 defpr"
"/setlinejoin 1 defpr/setmiterlimit 1 defpr/setdash{mark 3 1 roll 2 copy/setdas"
"h sysexec exch aload length 1 add -1 roll counttomark(setdash)prcmd pop}def/@s"
"etpagedevice{pop<<>>/setpagedevice sysexec matrix setmatrix newpath 0(setpaged"
"evice)prcmd}def/@checknulldev{@GD/@nulldev get{currentpagedevice maxlength 0 n"
"e{@GD/@nulldev false put 0 1(setnulldevice)prcmd}if}if}def/prcolor{currentcolo"
"rspace @setcolorspace currentrgbcolor 3(setrgbcolor)prcmd}def/printgstate{@dod"
"raw @GD/@nulldev get not and{matrix currentmatrix aload pop 6(setmatrix)prcmd "
"applyscalevals currentlinewidth 1(setlinewidth)prcmd currentlinecap 1(setlinec"
"ap)prcmd currentlinejoin 1(setlinejoin)prcmd currentmiterlimit 1(setmiterlimit"
")prcmd prcolor currentdash mark 3 1 roll exch aload length 1 add -1 roll count"
"tomark(setdash)prcmd pop}if}def/strconcat{exch dup length 2 index length add s"
"tring dup dup 4 2 roll copy length 4 -1 roll putinterval}def/setgstate{/setgst"
"ate sysexec printgstate}def/save{@UD begin/@saveID vmstatus pop pop def end :s"
"ave @saveID 1(save)prcmd}def/restore{:restore @checknulldev printgstate @UD/@s"
"aveID known{@UD begin @saveID end}{0}ifelse 1(restore)prcmd}def/gsave 0 defpr/"
"grestore{:grestore @checknulldev printgstate 0(grestore)prcmd}def/grestoreall{"
":grestoreall @checknulldev setstate 0(grestoreall)prcmd}def/rotate{dup type/ar"
"raytype ne @dodraw and{dup 1(rotate)prcmd}if/rotate sysexec applyscalevals}def"
"/scale{dup type/arraytype ne @dodraw and{2 copy 2(scale)prcmd}if/scale sysexec"
" applyscalevals}def/translate{dup type/arraytype ne @dodraw and{2 copy 2(trans"
"late)prcmd}if/translate sysexec}def/setmatrix{dup/setmatrix sysexec @dodraw{al"
"oad pop 6(setmatrix)prcmd applyscalevals}{pop}ifelse}def/initmatrix{matrix set"
"matrix}def/concat{matrix currentmatrix matrix concatmatrix setmatrix}def/makep"
"attern{gsave<</mx 3 -1 roll>>begin<</XUID[1000000 @patcnt]>>copy mx/makepatter"
"n sysexec dup begin PatternType 2 lt{PatternType @patcnt BBox aload pop XStep "
"YStep PaintType mx aload pop 15(makepattern)prcmd :newpath matrix setmatrix du"
"p PaintProc 0 1(makepattern)prcmd @GD/@patcnt @patcnt 1 add put}if end end gre"
"store}def/setpattern{begin PatternType 1 eq{PaintType 1 eq{XUID aload pop exch"
" pop 1}{:gsave[currentcolorspace aload length -1 roll pop]/setcolorspace sysex"
"ec/setcolor sysexec XUID aload pop exch pop currentrgbcolor :grestore 4}ifelse"
"(setpattern)prcmd currentcolorspace 0 get/Pattern ne{[/Pattern currentcolorspa"
"ce]/setcolorspace sysexec}if currentcolorspace @setcolorspace}{/setpattern sys"
"exec}ifelse end}def/setcolor{dup type/dicttype eq{setpattern}{/setcolor sysexe"
"c/currentrgbcolor sysexec setrgbcolor}ifelse}def/setcolorspace{dup/setcolorspa"
"ce sysexec @setcolorspace}def/@setcolorspace{dup type/arraytype eq{0 get}if/Pa"
"ttern eq{1}{0}ifelse 1(setcolorspace)prcmd}def/setgray 1 defpr/setcmykcolor 4 "
"defpr/sethsbcolor 3 defpr/setrgbcolor 3 defpr/.setopacityalpha{dup/.setopacity"
"alpha sysexec 1(setopacityalpha)prcmd}def/.setshapealpha{dup/.setshapealpha sy"
"sexec 1(setshapealpha)prcmd}def/.setblendmode{dup/.setblendmode sysexec<</Norm"
"al 0/Compatible 0/Multiply 1/Screen 2/Overlay 3/SoftLight 4/HardLight 5/ColorD"
"odge 6/ColorBurn 7/Darken 8/Lighten 9/Difference 10/Exclusion 11/Hue 12/Satura"
"tion 13/Color 14/Luminosity 15/CompatibleOverprint 16>>exch get 1(setblendmode"
")prcmd}def/@pdfpagecount{(r)file runpdfbegin pdfpagecount runpdfend}def/@pdfpa"
"gebox{(r)file runpdfbegin dup dup 1 lt exch pdfpagecount gt or{pop}{pdfgetpage"
"/MediaBox pget pop aload pop}ifelse runpdfend}def DELAYBIND{.bindnow}if ";

