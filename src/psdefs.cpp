/*************************************************************************
** psdefs.cpp                                                           **
**                                                                      **
** This file is part of dvisvgm -- a fast DVI to SVG converter          **
** Copyright (C) 2005-2020 Martin Gieseking <martin.gieseking@uos.de>   **
**                                                                      **
** This program is free software; you can redistribute it and/or        **
** modify it under the terms of the GNU General Public License as       **
** published by the Free Software Foundation; either version 3 of       **
** the License, or (at your option) any later version.                  **
**                                                                      **
** This program is distributed in the hope that it will be useful, but  **
** WITHOUT ANY WARRANTY; without even the implied warranty of           **
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the         **
** GNU General Public License for more details.                         **
**                                                                      **
** You should have received a copy of the GNU General Public License    **
** along with this program; if not, see <http://www.gnu.org/licenses/>. **
*************************************************************************/

#include "PSInterpreter.hpp"

const char *PSInterpreter::PSDEFS =
"<</Install{matrix setmatrix}/HWResolution[72 72]/PageSize[10000 10000]/Imaging"
"BBox null>>setpagedevice/@dodraw true store/@patcnt 0 store/@GD globaldict def"
"/@SD systemdict def/@UD userdict def @GD/@nulldev false put true setglobal @SD"
"/:save @SD/save get put @SD/:restore @SD/restore get put @SD/:gsave @SD/gsave "
"get put @SD/:grestore @SD/grestore get put @SD/:grestoreall @SD/grestoreall ge"
"t put @SD/:newpath @SD/newpath get put @SD/:stroke @SD/stroke get put @SD/:fil"
"l @SD/fill get put @SD/:eofill @SD/eofill get put @SD/:clip @SD/clip get put @"
"SD/:eoclip @SD/eoclip get put @SD/:charpath @SD/charpath get put @SD/:show @SD"
"/show get put @SD/:stringwidth @SD/stringwidth get put @SD/:nulldevice @SD/nul"
"ldevice get put @SD/:image @SD/image get put @SD/.setopacityalpha known not{@S"
"D/.setopacityalpha{pop}put}if @SD/.setshapealpha known not{@SD/.setshapealpha{"
"pop}put}if @SD/.setblendmode known not{@SD/.setblendmode{pop}put}if @SD/prseq{"
"-1 1{-1 roll =only( )print}for(\\n)print}put @SD/prcmd{( )exch(\\ndvi.)3{print"
"}repeat prseq}put @SD/cvxall{{cvx}forall}put @SD/defpr{[exch[/copy @SD]cvxall "
"5 -1 roll dup 6 1 roll[/get/exec]cvxall 6 -1 roll dup 7 1 roll 4 -1 roll dup 5"
" 1 roll dup length string cvs/prcmd cvx]cvx def}put @SD/querypos{{currentpoint"
"}stopped{$error/newerror false put}{2(querypos)prcmd}ifelse}put @SD/applyscale"
"vals{1 0 dtransform exch dup mul exch dup mul add sqrt 0 1 dtransform exch dup"
" mul exch dup mul add sqrt 1 0 dtransform dup mul exch dup dup mul 3 -1 roll a"
"dd dup 0 eq{pop}{sqrt div}ifelse 3(applyscalevals)prcmd}put @SD/prpath{{2(move"
"to)prcmd}{2(lineto)prcmd}{6(curveto)prcmd}{0(closepath)prcmd}pathforall}put @S"
"D/nulldevice{@GD/@nulldev true put :nulldevice 1 1(setnulldevice)prcmd}put @SD"
"/charpath{/@dodraw false store :charpath/@dodraw true store}put @SD/stringwidt"
"h{/@dodraw false store :stringwidth/@dodraw true store}put @SD/show{@dodraw @G"
"D/@nulldev get not and{dup :gsave currentpoint 2{50 mul exch}repeat :newpath m"
"oveto 50 50/scale sysexec true charpath fill :grestore/@dodraw false store :sh"
"ow/@dodraw true store}{:show}ifelse}put @SD/varxyshow{exch dup type/arraytype "
"eq{<</arr 3 -1 roll/prc 5 -1 roll/chr 1 string/idx 0>>begin{chr 0 3 -1 roll pu"
"t :gsave chr show :grestore currentpoint prc moveto/idx idx 1 add store}forall"
" end}{pop show}ifelse}put @SD/xyshow{{exch arr idx 2 mul get add exch arr idx "
"2 mul 1 add get add}varxyshow}put @SD/xshow{{exch arr idx get add exch}varxysh"
"ow}put @SD/yshow{{arr idx get add}varxyshow}put @SD/awidthshow{{1 string dup 0"
" 5 index put :gsave show :grestore pop 0 rmoveto 3 index eq{4 index 4 index rm"
"oveto}if 1 index 1 index rmoveto}exch cshow 5{pop}repeat}put @SD/widthshow{0 0"
" 3 -1 roll pstack awidthshow}put @SD/ashow{0 0 0 6 3 roll awidthshow}put @SD/n"
"ewpath{:newpath 1 1(newpath)prcmd}put @SD/stroke{@dodraw @GD/@nulldev get not "
"and{prcolor 0 1(newpath)prcmd prpath 0(stroke)prcmd :newpath}{:stroke}ifelse}p"
"ut @SD/fill{@dodraw @GD/@nulldev get not and{prcolor 0 1(newpath)prcmd prpath "
"0(fill)prcmd :newpath}{:fill}ifelse}put @SD/eofill{@dodraw @GD/@nulldev get no"
"t and{prcolor 0 1(newpath)prcmd prpath 0(eofill)prcmd :newpath}{:eofill}ifelse"
"}put @SD/clip{:clip @GD/@nulldev get not{0 1(newpath)prcmd prpath 0(clip)prcmd"
"}if}put @SD/eoclip{:eoclip @GD/@nulldev get not{0 1(newpath)prcmd prpath 0(eoc"
"lip)prcmd}}put @SD/shfill{begin currentdict/ShadingType known currentdict/Colo"
"rSpace known and currentdict/DataSource known and currentdict/Function known n"
"ot and ShadingType 4 ge and DataSource type/arraytype eq and{<</DeviceGray 1/D"
"eviceRGB 3/DeviceCMYK 4/bgknown currentdict/Background known/bbknown currentdi"
"ct/BBox known>>begin currentdict ColorSpace known{ShadingType ColorSpace load "
"bgknown{1 Background aload pop}{0}ifelse bbknown{1 BBox aload pop}{0}ifelse Sh"
"adingType 5 eq{VerticesPerRow}if DataSource aload length 4 add bgknown{ColorSp"
"ace load add}if bbknown{4 add}if ShadingType 5 eq{1 add}if(shfill)prcmd}if end"
"}if end}put @SD/image{dup type/dicttype eq{dup begin<</currdev currentdevice/p"
"ngdev/png16m finddevice/imgid currentfile fileposition/ctm matrix currentmatri"
"x>>begin mark/OutputFile(test-)imgid 20 string cvs stringconcat(.png)stringcon"
"cat/PageSize[Width Height]/UseFastColor true pngdev putdeviceprops setdevice[W"
"idth 0 0 Height neg 0 Height]/setmatrix sysexec :image ctm/setmatrix sysexec/c"
"opypage sysexec currdev setdevice imgid Width Height 3(image)prcmd end end}{:i"
"mage}ifelse}put/@rect{4 -2 roll moveto exch dup 0 rlineto exch 0 exch rlineto "
"neg 0 rlineto closepath}bind def/@rectcc{4 -2 roll moveto 2 copy 0 lt exch 0 l"
"t xor{dup 0 exch rlineto exch 0 rlineto neg 0 exch rlineto}{exch dup 0 rlineto"
" exch 0 exch rlineto neg 0 rlineto}ifelse closepath}bind def @SD/rectclip{:new"
"path dup type/arraytype eq{aload length 4 idiv{@rectcc}repeat}{@rectcc}ifelse "
"clip :newpath}put @SD/rectfill{gsave :newpath dup type/arraytype eq{aload leng"
"th 4 idiv{@rectcc}repeat}{@rectcc}ifelse fill grestore}put @SD/rectstroke{gsav"
"e :newpath dup type/arraytype eq{aload length 4 idiv{@rect}repeat}{@rect}ifels"
"e stroke grestore}put false setglobal @SD readonly pop/initclip 0 defpr/clippa"
"th 0 defpr/sysexec{@SD exch get exec}def/adddot{dup length 1 add string dup 0 "
"46 put dup 3 -1 roll 1 exch putinterval}def/setlinewidth{dup/setlinewidth syse"
"xec 1(setlinewidth)prcmd}def/setlinecap 1 defpr/setlinejoin 1 defpr/setmiterli"
"mit 1 defpr/setdash{mark 3 1 roll 2 copy/setdash sysexec exch aload length 1 a"
"dd -1 roll counttomark(setdash)prcmd pop}def/@setpagedevice{pop<<>>/setpagedev"
"ice sysexec matrix setmatrix newpath 0(setpagedevice)prcmd}def/@checknulldev{@"
"GD/@nulldev get{currentpagedevice maxlength 0 ne{@GD/@nulldev false put 0 1(se"
"tnulldevice)prcmd}if}if}def/prcolor{currentrgbcolor 3(setrgbcolor)prcmd}def/pr"
"intgstate{@dodraw @GD/@nulldev get not and{matrix currentmatrix aload pop 6(se"
"tmatrix)prcmd applyscalevals currentlinewidth 1(setlinewidth)prcmd currentline"
"cap 1(setlinecap)prcmd currentlinejoin 1(setlinejoin)prcmd currentmiterlimit 1"
"(setmiterlimit)prcmd currentrgbcolor 3(setrgbcolor)prcmd currentdash mark 3 1 "
"roll exch aload length 1 add -1 roll counttomark(setdash)prcmd pop}if}def/stri"
"ngconcat{exch dup length 2 index length add string dup dup 4 2 roll copy lengt"
"h 4 -1 roll putinterval}def/setgstate{/setgstate sysexec printgstate}def/save{"
"@UD begin/@saveID vmstatus pop pop def end :save @saveID 1(save)prcmd}def/rest"
"ore{:restore @checknulldev printgstate @UD/@saveID known{@UD begin @saveID end"
"}{0}ifelse 1(restore)prcmd}def/gsave 0 defpr/grestore{:grestore @checknulldev "
"printgstate 0(grestore)prcmd}def/grestoreall{:grestoreall @checknulldev setsta"
"te 0(grestoreall)prcmd}def/rotate{dup type/arraytype ne @dodraw and{dup 1(rota"
"te)prcmd}if/rotate sysexec applyscalevals}def/scale{dup type/arraytype ne @dod"
"raw and{2 copy 2(scale)prcmd}if/scale sysexec applyscalevals}def/translate{dup"
" type/arraytype ne @dodraw and{2 copy 2(translate)prcmd}if/translate sysexec}d"
"ef/setmatrix{dup/setmatrix sysexec @dodraw{aload pop 6(setmatrix)prcmd applysc"
"alevals}{pop}ifelse}def/initmatrix{matrix setmatrix}def/concat{matrix currentm"
"atrix matrix concatmatrix setmatrix}def/makepattern{gsave<</mx 3 -1 roll>>begi"
"n dup/XUID[1000000 @patcnt]put mx/makepattern sysexec dup dup begin PatternTyp"
"e @patcnt BBox aload pop XStep YStep PaintType mx aload pop 15(makepattern)prc"
"md :newpath matrix setmatrix PaintProc 0 1(makepattern)prcmd end/@patcnt @patc"
"nt 1 add store end grestore}def/setpattern{begin PatternType 1 eq{PaintType 1 "
"eq{XUID aload pop exch pop 1}{:gsave[currentcolorspace aload length -1 roll po"
"p]setcolorspace/setcolor sysexec XUID aload pop exch pop currentrgbcolor :gres"
"tore 4}ifelse(setpattern)prcmd}{/setpattern sysexec}ifelse end}def/setcolor{du"
"p type/dicttype eq{setpattern}{/setcolor sysexec/currentrgbcolor sysexec setrg"
"bcolor}ifelse}def/setgray 1 defpr/setcmykcolor 4 defpr/sethsbcolor 3 defpr/set"
"rgbcolor 3 defpr/.setopacityalpha{dup/.setopacityalpha sysexec 1(setopacityalp"
"ha)prcmd}def/.setshapealpha{dup/.setshapealpha sysexec 1(setshapealpha)prcmd}d"
"ef/.setblendmode{dup/.setblendmode sysexec<</Normal 0/Compatible 0/Multiply 1/"
"Screen 2/Overlay 3/SoftLight 4/HardLight 5/ColorDodge 6/ColorBurn 7/Darken 8/L"
"ighten 9/Difference 10/Exclusion 11/Hue 12/Saturation 13/Color 14/Luminosity 1"
"5/CompatibleOverprint 16>>exch get 1(setblendmode)prcmd}def/@pdfpagecount{(r)f"
"ile runpdfbegin pdfpagecount runpdfend}def/@pdfpagebox{(r)file runpdfbegin dup"
" dup 1 lt exch pdfpagecount gt or{pop}{pdfgetpage/MediaBox pget pop aload pop}"
"ifelse runpdfend}def DELAYBIND{.bindnow}if ";

